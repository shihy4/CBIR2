import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.*;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.BevelBorder;
import javax.swing.border.TitledBorder;
import javax.swing.JRadioButton;
import java.awt.SystemColor;
import javax.swing.SwingConstants;
import javax.swing.JSplitPane;
import java.awt.GridLayout;

/******************************************************************************
 * <pre>
 * Class:       CBIR
 * File:        CBIR.java
 * Description: This is a CBIR main program that runs the GUI. 
 *              
 * @author      Yun-Ming Shih (Jas)
 * Professor:   Dr. Min Chen
 * Course:      CSS 584 Autumn 2016
 * Project:     Project 1 - Implement a simple content-based image retrieval
 *                          system.
 * Due:         Oct 11 2016
 * Environment: iMac, OS X 10.11.6, NetBeans IDE 8.1, Java 1.8.0, Intel i5
 * @version     1.0
 * @see java.awt.Color;
 * @see java.awt.Font;
 * @see java.awt.event.ActionEvent;
 * @see java.awt.event.ActionListener;
 * @see java.util.*;
 * @see java.io.*;
 * @see java.util.HashMap;
 * @see java.util.Map;
 * @see java.util.logging.Level;
 * @see java.util.logging.Logger;
 * @see javax.swing.BorderFactory;
 * @see javax.swing.ImageIcon;
 * @see javax.swing.JButton;
 * @see javax.swing.JFrame;
 * @see javax.swing.SwingUtilities;
 * @see javax.swing.border.BevelBorder;
 * @see javax.swing.border.TitledBorder;
 </pre>
 *****************************************************************************/
public class CBIR extends JFrame {
    private static final int SPLASH_DURATION = 4000;
    private final static int INTENSITY_BIN_SIZE = 26;
    private final static int COLOR_CODE_BIN_SIZE = 64;
    private final static int INT_CC_COLUMN_SIZE = 89;
    private final static int TOTAL_IMAGE = 101;
    private final Color FONT_COLOR = new Color(102,102,102);
    private final Color BUTTON_BACKGROUD = new Color(72, 62, 77);
    private final Color DISABLED_FONT_COLOR = new Color(200, 200, 200);
    private final Color GREEN_LIGHT = new Color(60,179,113);
    private final JButton[] button; //creates an array of JButtons
    private final JCheckBox[] checkBox; //creates an array of JCheckBoxes
    private final int[] buttonOrder; //creates an array to keep up the image order 
    private final int[] imageSize; // keeps up with the image sizes
    private int[][] intensityMatrix;
    private int[][] colorCodeMatrix;
    private double[][] normalizedMatrix;
    private Map<Integer, LinkedList<Integer>> colorCodeMap;
    private Map<Integer, LinkedList<Integer>> intensityMap; 
    int picNo = 0;
    int imageCount = 1; //keeps up with the number of images displayed
    int pageNo = 1;
    boolean relevantOn = false;

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panelLeft = new javax.swing.JPanel();
        panelRight = new javax.swing.JPanel();
        photographLabel = new javax.swing.JLabel();
        bottomRightPanel = new javax.swing.JPanel();
        infoLable = new javax.swing.JPanel();
        logoLable = new javax.swing.JLabel();
        logoLable.setBackground(new Color(47, 79, 79));
        buttonPanel = new javax.swing.JPanel();
        previousPage = new javax.swing.JButton();
        pageInfo = new javax.swing.JLabel();
        nextPage = new javax.swing.JButton();
        intensity = new javax.swing.JButton();
        colorCode = new javax.swing.JButton();
        menuesJMenuBar = new javax.swing.JMenuBar();
        fileJMenu = new javax.swing.JMenu();
        printJMenuItem = new javax.swing.JMenuItem();
        resetJMenuItem = new javax.swing.JMenuItem();
        aboutJMenuItem = new javax.swing.JMenuItem();
        exitJMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("C B I R");
        setBackground(new java.awt.Color(255, 255, 255));
        setBounds(new java.awt.Rectangle(52, 0, 1100, 750));
        setMinimumSize(new java.awt.Dimension(1100, 750));
        setPreferredSize(new java.awt.Dimension(1100, 750));
        getContentPane().setLayout(new java.awt.GridLayout(1, 2, 5, 5));

        panelLeft.setBackground(new java.awt.Color(255, 255, 255));
        panelLeft.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Gallery - Please Select an Image", 
                javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, 
                new java.awt.Font("Lucida Grande", 1, 13), new java.awt.Color(102, 102, 102))); // NOI18N
        panelLeft.setLayout(new java.awt.GridLayout(5, 4, 5, 5));
        getContentPane().add(panelLeft);

        panelRight.setBackground(new java.awt.Color(255, 255, 255));
        panelRight.setLayout(new java.awt.GridLayout(2, 1, 5, 5));

        photographLabel.setBackground(new java.awt.Color(255, 255, 255));
        photographLabel.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        photographLabel.setForeground(new java.awt.Color(102, 102, 102));
        photographLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        photographLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("logo/not-selected.png"))); // NOI18N
        photographLabel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Photo", 
                javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, 
                javax.swing.border.TitledBorder.DEFAULT_POSITION, 
                new java.awt.Font("Lucida Grande", 1, 14), new java.awt.Color(102, 102, 102))); // NOI18N
        photographLabel.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        photographLabel.setSize(new java.awt.Dimension(400, 300));
        photographLabel.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        panelRight.add(photographLabel);

        bottomRightPanel.setBackground(new java.awt.Color(255, 255, 255));
        bottomRightPanel.setLayout(new java.awt.GridLayout(2, 1, 5, 5));

        infoLable.setBackground(new java.awt.Color(255, 255, 255));
        infoLable.setLayout(new java.awt.GridLayout(1, 1));

        logoLable.setIcon(new javax.swing.ImageIcon(getClass().getResource("logo/logo2.png")));
        infoLable.add(logoLable);

        bottomRightPanel.add(infoLable);

        buttonPanel.setBackground(new java.awt.Color(255, 255, 255));
        buttonPanel.setLayout(new java.awt.GridLayout(2, 3, 5, 5));

        previousPage.setBackground(BUTTON_BACKGROUD);
        previousPage.setFont(new Font("Lucida Grande", Font.BOLD, 14)); // NOI18N
        previousPage.setForeground(new java.awt.Color(255, 255, 255));
        previousPage.setText("<");
        previousPage.setToolTipText("Previous page");
        previousPage.addActionListener(new CBIR.previousPageHandler());
        buttonPanel.add(previousPage);

        pageInfo.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        pageInfo.setForeground(new java.awt.Color(102, 102, 102));
        pageInfo.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        pageInfo.setToolTipText("");
        buttonPanel.add(pageInfo);

        nextPage.setBackground(BUTTON_BACKGROUD);
        nextPage.setFont(new java.awt.Font("Lucida Grande", 1, 36)); // NOI18N
        nextPage.setForeground(new java.awt.Color(255, 255, 255));
        nextPage.setText(">");
        nextPage.setToolTipText("Next page");
        nextPage.addActionListener(new CBIR.nextPageHandler());
        buttonPanel.add(nextPage);

        intensity.setBackground(BUTTON_BACKGROUD);
        intensity.setFont(new java.awt.Font("Lucida Grande", 1, 18)); // NOI18N
        intensity.setForeground(new java.awt.Color(255, 255, 255));
        intensity.setText("Intensity");
        intensity.setToolTipText("Retrieve images using intensity method");
        intensity.addActionListener(new CBIR.intensityHandler());
        resetButton = new javax.swing.JButton();
        resetButton.setBackground(BUTTON_BACKGROUD);
        resetButton.setFont(new java.awt.Font("Lucida Grande", 1, 18)); // NOI18N
        resetButton.setForeground(new java.awt.Color(255, 255, 255));
        resetButton.setText("Reset");
        resetButton.setToolTipText("Reset to default stage");
        resetButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(resetButton);
        buttonPanel.add(intensity);

        colorCode.setBackground(BUTTON_BACKGROUD);
        colorCode.setFont(new java.awt.Font("Lucida Grande", 1, 18)); // NOI18N
        colorCode.setForeground(new java.awt.Color(255, 255, 255));
        colorCode.setText("Color Code");
        colorCode.setToolTipText("Retreive images using color code mehtod");
        colorCode.addActionListener(new colorCodeHandler());
        buttonPanel.add(colorCode);

        bottomRightPanel.add(buttonPanel);
        
        rfPanel = new JPanel();
        rfPanel.setBackground(Color.WHITE);
        buttonPanel.add(rfPanel);
        rfPanel.setLayout(new GridLayout(3, 1, 2, 2));
        

        relevantButton = new JRadioButton("Relevance Off");
        rfPanel.add(relevantButton);
        relevantButton.setForeground(DISABLED_FONT_COLOR);
        relevantButton.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        relevantButton.setEnabled(false);
        
        selectAll = new JButton("Check All");
        selectAll.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // set select all to true to select all
                selectAllCheckBoxes(true);
            }
        });
        rfPanel.add(selectAll);
        selectAll.setToolTipText("Intensity + Color Code with Relevance Feedback");
        selectAll.setForeground(Color.WHITE);
        selectAll.setFont(new Font("Lucida Grande", Font.BOLD, 14));
        selectAll.setBackground(new Color(72, 62, 77));
        
        deselectAll = new JButton("Uncheck All");
        deselectAll.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // set select all to false to deselect all
                selectAllCheckBoxes(false);
            }
        });
        rfPanel.add(deselectAll);
        deselectAll.setToolTipText("Intensity + Color Code with Relevance Feedback");
        deselectAll.setForeground(Color.WHITE);
        deselectAll.setFont(new Font("Lucida Grande", Font.BOLD, 14));
        deselectAll.setBackground(new Color(72, 62, 77));
        relevantButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                relevantOn = !relevantOn;
                setReleventButtonDependents(relevantOn);
            }
        });
        
        intCCButton = new JButton("RF");
        intCCButton.setBackground(BUTTON_BACKGROUD);
        intCCButton.setForeground(new java.awt.Color(255, 255, 255));
        intCCButton.setFont(new java.awt.Font("Lucida Grande", 1, 18)); // NOI18N
        intCCButton.setToolTipText("Intensity + Color Code with Relevance Feedback");
        intCCButton.addActionListener(new RF_Handler());
        buttonPanel.add(intCCButton);

        panelRight.add(bottomRightPanel);
        bottomRightPanel.getAccessibleContext().setAccessibleName("");

        getContentPane().add(panelRight);

        menuesJMenuBar.setBorder(null);
        menuesJMenuBar.setForeground(FONT_COLOR);

        fileJMenu.setMnemonic('m');
        fileJMenu.setText("Menu");
        fileJMenu.setToolTipText("Clear selected, Print selected, or Exit program");

        printJMenuItem.setMnemonic('P');
        printJMenuItem.setText("Print");
        printJMenuItem.setToolTipText("Print page");
        printJMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                printJMenuItemActionPerformed(evt);
            }
        });
        fileJMenu.add(printJMenuItem);

        resetJMenuItem.setMnemonic('R');
        resetJMenuItem.setText("Reset");
        resetJMenuItem.setToolTipText("Reset");
        resetJMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetJMenuItemActionPerformed(evt);
            }
        });
        fileJMenu.add(resetJMenuItem);

        aboutJMenuItem.setMnemonic('A');
        aboutJMenuItem.setText("About");
        aboutJMenuItem.setToolTipText("About this application");
        aboutJMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aboutJMenuItemActionPerformed(evt);
            }
        });
        fileJMenu.add(aboutJMenuItem);

        exitJMenuItem.setMnemonic('E');
        exitJMenuItem.setText("Exit");
        exitJMenuItem.setToolTipText("Exits the program");
        exitJMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitJMenuItemActionPerformed(evt);
            }
        });
        fileJMenu.add(exitJMenuItem);

        menuesJMenuBar.add(fileJMenu);

        setJMenuBar(menuesJMenuBar);

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void resetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetButtonActionPerformed
        resetButtonClicked();
    }//GEN-LAST:event_resetButtonActionPerformed

    private void printJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_printJMenuItemActionPerformed
        try {
            PrintUtilities.printComponent(this);
        }
        catch (Exception e){}
    }//GEN-LAST:event_printJMenuItemActionPerformed

    private void exitJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitJMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitJMenuItemActionPerformed

    private void aboutJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutJMenuItemActionPerformed
        About aboutPage = new About();
        aboutPage.setVisible(true);
    }//GEN-LAST:event_aboutJMenuItemActionPerformed

    private void resetJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetJMenuItemActionPerformed
        resetButtonClicked();
    }//GEN-LAST:event_resetJMenuItemActionPerformed

    /**************************************************************************
     * CBIR constructor
     * - Creates new form CBIR
     *************************************************************************/
    public CBIR() {
        buttonOrder = new int[TOTAL_IMAGE]; 
        imageSize = new int[TOTAL_IMAGE]; 
        intensityMatrix = new int[TOTAL_IMAGE][INTENSITY_BIN_SIZE];
        colorCodeMatrix = new int[TOTAL_IMAGE][COLOR_CODE_BIN_SIZE];
        colorCodeMap = new HashMap<>();
        intensityMap = new HashMap<>();
        button = new JButton[TOTAL_IMAGE];
        checkBox = new JCheckBox[TOTAL_IMAGE];
        
        initComponents(); // auto generated codes for GUI
        
        // load button once when program starts; creates check boxes as well
        loadButtonsAndCreateCheckBoxes(); 
        
        // if not both intensity and color code processed then process them
        boolean intenityFileFailed = readIntensityFile();
        boolean colorCodeFileFailed = readColorCodeFile();
        boolean normalizedFileFailed = readNormalizedFile();
        if(intenityFileFailed || colorCodeFileFailed || normalizedFileFailed) {
            readImage ri = new readImage();
            intenityFileFailed = readIntensityFile();
            colorCodeFileFailed = readColorCodeFile();
        }
        setImageSizes();
        displayPage();
    }
    
    /**************************************************************************
     * loadButtonsAndCreateCheckBoxes - Loads the 100 images to buttons 
     *                                  Also creates check boxes
     * - Only called once when CBIR starts
     *************************************************************************/
    private void loadButtonsAndCreateCheckBoxes() {
        /* This for loop goes through the images in the database and stores 
         * them as icons and adds
         * the images to JButtons and then to the JButton array
         */
        for (int i = 1; i < TOTAL_IMAGE; i++) {
            String imageName = i + ".jpg";
            ImageIcon icon;
            icon = new ImageIcon(getClass().getResource(
                    "images/" + imageName));

            if (icon != null) {
                button[i] = new JButton(icon);
                checkBox[i] = new JCheckBox();
                button[i].setToolTipText(i + ".jpg");
                button[i].setBorder(BorderFactory.createTitledBorder(
                        BorderFactory.createBevelBorder(BevelBorder.RAISED), 
                        imageName, 
                        TitledBorder.CENTER, TitledBorder.TOP, 
                        new Font("Lucida Grande", Font.BOLD, 14), 
                        new Color(255, 255, 255))); 
                
                checkBox[i].setText(imageName); 
                checkBox[i].setFont(new Font("Lucida Grande", Font.BOLD, 14));
                checkBox[i].setForeground(FONT_COLOR);
                checkBox[i].setEnabled(relevantOn);
                checkBox[i].setVerticalAlignment(SwingConstants.BOTTOM);
               
                panelLeft.add(button[i]);
                button[i].addActionListener(
                        new CBIR.IconButtonHandler(i, icon));
                buttonOrder[i] = i;
            }
        }
    }
    
    /**************************************************************************
     * setImageSizes - Loop through intensityMatrix to get size for all images 
     *************************************************************************/
    private void setImageSizes() {
        for(int i = 1; i < TOTAL_IMAGE; i++) {
            imageSize[i] = intensityMatrix[i][0];
        }
    }

    /**************************************************************************
     * resetButtonClicked - This method resets the photo orders from 1 - 100 
     * and clears the photo label
     *************************************************************************/
    private void resetButtonClicked() {
        for (int i = 1; i < TOTAL_IMAGE; i++) {
            buttonOrder[i] = i;
        }
        photographLabel.setIcon(new ImageIcon(getClass().
                getResource("logo/not-selected.png")));
        picNo = 0;
        setPhotoBorderTitle();
        displayPage();
        
        resetCheckBoxes();
        if(relevantOn) {
            relevantOn = !relevantOn;
        }
        setReleventButtonDependents(relevantOn);
        relevantButton.setSelected(false);
        enableRelevantButton(false);
        
    }
    
    /**************************************************************************
     * setImageSizes - Loop through intensityMatrix to get size for all images 
     *************************************************************************/
    private void resetCheckBoxes() {
        for(int i = 1; i < TOTAL_IMAGE; i++) {
            checkBox[i].setSelected(false);
        }
    }

    /**************************************************************************
     * readIntensityFile - This method opens the intensity text file containing
     * the intensity matrix with the histogram bin values for each image
     * - The contents of the matrix are processed and stored in a two 
     *   dimensional array called intensityMatrix
     * @return success or failed
     *************************************************************************/
    private boolean readIntensityFile() {
        boolean failed = true;
        try {
        // writes the object to file so later can access directly from object
            ObjectInputStream in = new ObjectInputStream(
                    new FileInputStream("intensity.txt"));
            intensityMatrix = (int[][]) in.readObject();
            failed = false;
        } catch (FileNotFoundException EE) {
            System.out.println("The file intensity.txt does not exist");
        } catch (IOException ex) {
            Logger.getLogger(CBIR.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(CBIR.class.getName()).log(Level.SEVERE, null, ex);
        }
        return failed;
    }


    /**************************************************************************
     * readColorCodeFile - This method opens the intensity text file containing
     * the color code matrix with the histogram bin values for each image
     * - The contents of the matrix are processed and stored in a two 
     *   dimensional array called colorCodeMatrix
     * @return success or failed
     *************************************************************************/
    private boolean readColorCodeFile() {
        boolean failed = true;
        try {
        // writes the object to file so later can access directly from object
            ObjectInputStream in = new ObjectInputStream(
                    new FileInputStream("colorCodes.txt"));
            colorCodeMatrix = (int[][]) in.readObject();
            failed = false;
        } catch (FileNotFoundException EE) {
            System.out.println("The file colorCodes.txt does not exist");
        } catch (IOException ex) {
            Logger.getLogger(CBIR.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(CBIR.class.getName()).log(Level.SEVERE, null, ex);
        }
        return failed;
    }

    /**************************************************************************
     * readNormalizedFile - This method opens the normalized text file 
     * containing the normalized feature matrix values for each image
     * - The contents of the matrix are processed and stored in a two 
     *   dimensional array called normalizedMatrix
     * @return success or failed
     *************************************************************************/
    private boolean readNormalizedFile() {
        boolean failed = true;
        try {
        // writes the object to file so later can access directly from object
            ObjectInputStream in = new ObjectInputStream(
                    new FileInputStream("normalized.txt"));
            normalizedMatrix = (double[][]) in.readObject();
            
// CHECK WITH GALEN
//            for(int i = 90; i < 101; i++) {
//              System.out.print("Image " + (i - 1) + " normalized features: [");
//              for(int j = 0; j < 88; j++ ) {
//                  System.out.print(normalizedMatrix[i][j] +", ");
//              }System.out.println(normalizedMatrix[i][88] +"]");
//            }
//            
           
// CHECK WITH JIA
//              for(int j = 0; j < 89; j++ ) {
//                  System.out.print(normalizedMatrix[1][j] +",");
//              }
            
            
            
            
            failed = false;
        } catch (FileNotFoundException EE) {
            System.out.println("The file normalized.txt does not exist");
        } catch (IOException ex) {
            Logger.getLogger(CBIR.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(CBIR.class.getName()).log(Level.SEVERE, null, ex);
        }
        return failed;
    }
    
    
//    /**************************************************************************
//     * displayFirstPage - This method displays the first twenty images in the 
//     * panelBottom
//     * - The for loop starts at number one and gets the image
//     *   number stored in the buttonOrder array and assigns the value to 
//     *   imageButNo
//     * - The button associated with the image is then added to panelBottom1
//     * - The for loop continues this process until twenty images are displayed 
//     *   in the panelBottom1
//     *************************************************************************/
//    private void displayFirstPage() {
//        int imageButNo;
//        panelLeft.removeAll();
//        imageCount = 1;
//        for (int i = 1; i < 21; i++) {
//            imageButNo = buttonOrder[i];
//            panelLeft.add(button[imageButNo]);
//            panelLeft.add(checkBox[imageButNo]);
//            imageCount++;
//        }
//        pageNo = 1;
//        pageInfo.setText(" Page " + pageNo + " of 5 ");
//        nextPage.setEnabled(true);
//        previousPage.setEnabled(false);
//        panelLeft.revalidate();
//        panelLeft.repaint();
//        setPhotoBorderTitle(); 
//    }

 
    /**************************************************************************
     * displayFirstPage - This method displays the first twenty images in the 
     * panelBottom
     * - The for loop starts at number one and gets the image
     *   number stored in the buttonOrder array and assigns the value to 
     *   imageButNo
     * - The button associated with the image is then added to panelBottom1
     * - The for loop continues this process until twenty images are displayed 
     *   in the panelBottom1
     *************************************************************************/
    private void displayPage() {
        int imageButNo;
        panelLeft.removeAll();
        imageCount = 1;
        enableCheckBoxes(relevantOn);
        for (int i = 1; i < 21; i++) {
            imageButNo = buttonOrder[i];
            
//          JPanel holder = new JPanel();
//          holder.setLayout(new BorderLayout());
//          holder.setBackground(Color.WHITE);
//            holder.add(button[imageButNo], BorderLayout.CENTER);
//            holder.add(checkBox[imageButNo], BorderLayout.SOUTH);
//            panelLeft.add(holder);
            
            
            putButtonAndCheckboxIntoHolder(imageButNo);
            
            
            imageCount++;
        }
        pageNo = 1;
        pageInfo.setText(" Page " + pageNo + " of 5 ");
        nextPage.setEnabled(true);
        previousPage.setEnabled(false);
        panelLeft.revalidate();
        panelLeft.repaint();
        setPhotoBorderTitle(); 
    }
    
    
    private void putButtonAndCheckboxIntoHolder(int imageButNo) {
        JPanel holder = new JPanel();
        holder.setLayout(new BorderLayout());
        holder.setBackground(Color.WHITE);
        holder.add(button[imageButNo], BorderLayout.CENTER);
        holder.add(checkBox[imageButNo], BorderLayout.SOUTH);
        panelLeft.add(holder);
    }
    
    /**************************************************************************
     * enableCheckBox - Enables or disables all check boxes
     * @param enable_it the check boxes
     *************************************************************************/
    private void enableCheckBoxes(boolean enable_it) {
        for(int i = 1; i <TOTAL_IMAGE; i++) {
            checkBox[i].setEnabled(enable_it);
            Color fontColor = (enable_it) ? FONT_COLOR : DISABLED_FONT_COLOR; 
            checkBox[i].setForeground(fontColor);
        }
    }
    
    
    /**************************************************************************
     * setPhotoBorderTitle - Sets photo section title
     *************************************************************************/
    private void setPhotoBorderTitle() {
        String title = "Photo";
        if(picNo > 0) {
            title += " " + picNo + ".jpg";
        } 
        photographLabel.setBorder(BorderFactory.createTitledBorder(
                null, title, TitledBorder.DEFAULT_JUSTIFICATION, 
                TitledBorder.DEFAULT_POSITION, 
                new Font("Lucida Grande", 1, 14), 
                FONT_COLOR)); 
    }
    
    
    
    /**************************************************************************
     * relevantButtonOn - Sets all relevant button dependent components
     * @param on if the relevant button status is on
     *************************************************************************/
    private void setReleventButtonDependents(boolean on) {
       if (on) {
           relevantButton.setForeground(GREEN_LIGHT);
           
       } else {
           relevantButton.setForeground(FONT_COLOR);
       }
       enableCheckBoxes(on);
    }
    
    
    /**************************************************************************
     * enableRelevantButton - Sets and enables/disables Relevant button 
     * @param enabled if is clicked
     *************************************************************************/
    private void enableRelevantButton(boolean enabled) {
        if (enabled) {
           relevantButton.setEnabled(enabled);
           relevantButton.setForeground(FONT_COLOR);
       } else {
           relevantButton.setEnabled(enabled);
           relevantButton.setForeground(DISABLED_FONT_COLOR);
       }
    }
    
    
    /**************************************************************************
     * selectAllCheckBoxes - Selects all check boxes
     * @param allOn true selects all, otherwise deselect all
     *************************************************************************/
    private void selectAllCheckBoxes(boolean allOn) {
        if(relevantOn) {
            for(int i = 1; i < TOTAL_IMAGE; i++) {
                checkBox[i].setSelected(allOn);
            }
        }
    }
    
    /**************************************************************************
     * IconButtonHandler class - This class implements an ActionListener for 
     *                           each iconButton
     * - When an icon button is clicked, the image on the 
     *   the button is added to the photographLabel and the picNo is set to the 
     *   image number selected and being displayed
     *************************************************************************/
    private class IconButtonHandler implements ActionListener {
        int pNo = 0;
        ImageIcon iconUsed;

        IconButtonHandler(int i, ImageIcon j) {
            pNo = i;
            iconUsed = j;  //sets the icon to the one used in the button
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            photographLabel.setIcon(iconUsed);
            picNo = pNo;
            setPhotoBorderTitle();
            enableRelevantButton(true);
        }

    }

    /**************************************************************************
     * nextPageHandler class - This class implements an ActionListener for 
     *                         the nextPageButton 
     * - The last image number to be displayed is set to the 
     *   current image count plus 20
     * - If the endImage number equals 101, then the next page button does not 
     *   display any new images because there are only 100 images to be 
     *   displayed
     * - The first picture on the next page is the image located in 
     *   the buttonOrder array at the imageCount
     *************************************************************************/
    private class nextPageHandler implements ActionListener {

        @Override
        public void actionPerformed(ActionEvent e) {
            int imageButNo;
            int endImage = imageCount + 20;
            if (endImage <= 101) {
                previousPage.setEnabled(true);
                panelLeft.removeAll();
                for (int i = imageCount; i < endImage; i++) {
                    imageButNo = buttonOrder[i];
//                  JPanel holder = new JPanel();
//                  holder.setLayout(new BorderLayout());
//                  holder.setBackground(Color.WHITE);
//                  holder.add(button[imageButNo], BorderLayout.CENTER);
//                    holder.add(checkBox[imageButNo], BorderLayout.SOUTH);
//                    panelLeft.add(holder);
                    putButtonAndCheckboxIntoHolder(imageButNo);
                    imageCount++;
                }
                pageNo++;
                pageInfo.setText(" Page " + pageNo + " of 5 ");
                panelLeft.revalidate();
                panelLeft.repaint();
            } else {
                nextPage.setEnabled(false);
            }
        }
    }

    /**************************************************************************
     * previousPageHandler class - This class implements an ActionListener for
     *                             the previousPageButton 
     * - The last image number to be displayed is set to the current image 
     *   count minus 40
     * - If the endImage number is less than 1, then the previous page button
     *   does not display any new images because the starting image is 1 
     * - The first picture on the next page is the image located in the 
     *   buttonOrder array at the imageCount
     *************************************************************************/
    private class previousPageHandler implements ActionListener {

        @Override
        public void actionPerformed(ActionEvent e) {
            int imageButNo = 0;
            int startImage = imageCount - 40;
            int endImage = imageCount - 20;
            if (startImage >= 1) {
                nextPage.setEnabled(true);
                panelLeft.removeAll();
                for (int i = startImage; i < endImage; i++) {
                    imageButNo = buttonOrder[i];
////                    panelLeft.add(button[imageButNo]);
//                  imageButNo = buttonOrder[i];
//                  JPanel holder = new JPanel();
//                  holder.setLayout(new BorderLayout());
//                  holder.setBackground(Color.WHITE);
//                  holder.add(button[imageButNo], BorderLayout.CENTER);
//                    holder.add(checkBox[imageButNo], BorderLayout.SOUTH);
//                    panelLeft.add(holder);
                    putButtonAndCheckboxIntoHolder(imageButNo);
                    imageCount--;
                }
                pageNo--;
                pageInfo.setText(" Page " + pageNo + " of 5 ");
                panelLeft.revalidate();
                panelLeft.repaint();
            } else {
                previousPage.setEnabled(false);
            }
        }
    }
    

    /**************************************************************************
     * intensityHandler class - This class implements an ActionListener when 
     *                          the user selects the intensityHandler button
     * - The image number that the user would like to find similar images for 
     *   is stored in the variable pic
     * - pic takes the image number associated with the image selected and 
     *   subtracts one to account for the fact that the intensityMatrix starts 
     *   with zero and not one
     * - The size of the image is retrieved from the imageSize array
     * - The selected image's intensity bin values are compared to all the 
     *   other image's intensity bin values and a score is determined for how 
     *   well the images compare
     * - The images are then arranged from most similar to the least
     *************************************************************************/
    private class intensityHandler implements ActionListener {

        @Override
        public void actionPerformed(ActionEvent e) {
            intensityMap = readIntensityResultFile();

            // if intensityMap doesn't have the selected image
            if(intensityMap == null || !intensityMap.containsKey(picNo)) {
                setIntensityMap(picNo);
                writeToIntensityResultFile();
            } 
            LinkedList<Integer> newOrder = intensityMap.get(picNo);
            for(int i = 1; i < TOTAL_IMAGE; i++) {
                buttonOrder[i] = newOrder.get(i - 1);
            }
            displayPage();

        }
        
        /**********************************************************************
         * setIntensityMap - sets the intensity map if intensity map is empty
         *                   or doesn't have the key requested
         * - This method calculates the Manhattan Distance
         * @param i the image number
         *********************************************************************/
        private void setIntensityMap(int i) {
            Map<Double, LinkedList<Integer>> map = new TreeMap<>();
            int picSize = imageSize[i];

            double distanceKey, normalizedHi, normalizedHk; 
            for(int k = 1; k < 101; k++) {
                distanceKey = 0;
                for(int j = 1; j < INTENSITY_BIN_SIZE; j++) {
                    normalizedHi = (double)intensityMatrix[i][j] / 
                            (double)(picSize);
                    normalizedHk = (double)intensityMatrix[k][j] / 
                            (double)(imageSize[k]);
                    distanceKey += Math.abs(normalizedHi - normalizedHk);
                }

                if(map.keySet().contains(distanceKey)) {
                    map.get(distanceKey).add(k);
                } else {
                    LinkedList<Integer> list = new LinkedList<>();
                    list.add(k);
                    map.put(distanceKey, list);
                }
            }
            LinkedList<Integer> processedList = new LinkedList<>();
                
            map.entrySet().stream().forEach((entry) -> {
                processedList.addAll(entry.getValue());
            });
            intensityMap.put(picNo, processedList);
        }
        
        /**********************************************************************
         * readIntensityResultFile - This method opens the intensity text file
         *                           containing the intensity matrix with the 
         *                           histogram bin values for each image
         * - The contents of the matrix are processed and stored in a two 
         *   dimensional array called intensityMatrix.
         * @return updated map
         *********************************************************************/
        private HashMap<Integer,LinkedList<Integer>> readIntensityResultFile(){
            try {
                ObjectInputStream in = new ObjectInputStream(
                        new FileInputStream("intensityResult.txt"));

                return (HashMap<Integer, LinkedList<Integer>>) in.readObject();
            } catch (FileNotFoundException EE) {
                System.out.println(
                        "The file intensityResult.txt does not exist");
            } catch (IOException ex) {
                Logger.getLogger(CBIR.class.getName())
                        .log(Level.SEVERE, null, ex);
            } catch (ClassNotFoundException ex) {
                Logger.getLogger(CBIR.class.getName())
                        .log(Level.SEVERE, null, ex);
            }
            return (new HashMap<>());
        }
        
        /**********************************************************************
         * writeToIntensityResultFile - writes updated map to file
         *********************************************************************/
        private void writeToIntensityResultFile() {
            try {
                ObjectOutputStream out = new ObjectOutputStream(
                    new FileOutputStream("intensityResult.txt")); 

                out.writeObject(intensityMap);
            } catch (IOException ex) {
                Logger.getLogger(readImage.class.getName()).log(
                        Level.SEVERE, null, ex);
            }
        }
        
    }


    /**************************************************************************
     * colorCodeHandler class - This class implements an ActionListener when 
     *                          the user selects the colorCodeHandler button
     * - The image number that the user would like to find similar images for 
     *   is stored in the variable pic
     * - pic takes the image number associated with the image selected and 
     *   subtracts one to account for the fact that the colorCodeMatrix starts 
     *   with zero and not one
     * - The size of the image is retrieved from the imageSize array
     * - The selected image's color code bin values are compared to all the 
     *   other image's color code bin values and a score is determined for how 
     *   well the images compare
     * - The images are then arranged from most similar to the least
     *************************************************************************/
    private class colorCodeHandler implements ActionListener {
       
        @Override
        public void actionPerformed(ActionEvent e) {

            colorCodeMap = readColorCodeResultFile();
            
            // if coloCodeMap doesn't have the selected image
            if(colorCodeMap == null || !colorCodeMap.containsKey(picNo)) {
                setColorCodeMap(picNo);
                writeToColorCodeResultFile();
            } 
            
            LinkedList<Integer> newOrder = colorCodeMap.get(picNo);
            for(int i = 1; i < TOTAL_IMAGE; i++) {
                buttonOrder[i] = newOrder.get(i - 1);
            }
            
            displayPage();
        }
        
        /**********************************************************************
         * setColorCodeMap - sets the colorCode map if intensity map is empty
         *                   or doesn't have the key requested
         * - This method calculates the Manhattan Distance
         * @param i the image number
         *********************************************************************/
        private void setColorCodeMap(int i) {
            Map<Double, LinkedList<Integer>> map = new TreeMap<>();
            int picSize = imageSize[i];

            double distanceKey, normalizedHi, normalizedHk; 
            for(int k = 1; k < 101; k++) {
                distanceKey = 0;
                for(int j = 0; j < COLOR_CODE_BIN_SIZE; j++) {
                    normalizedHi = (double)colorCodeMatrix[i][j] / 
                            (double)(picSize);
                    normalizedHk = (double)colorCodeMatrix[k][j] / 
                            (double)(imageSize[k]);
                    distanceKey += Math.abs(normalizedHi - normalizedHk);
                }

                if(map.keySet().contains(distanceKey)) {
                    map.get(distanceKey).add(k);
                } else {
                    LinkedList<Integer> list = new LinkedList<>();
                    list.add(k);
                    map.put(distanceKey, list);
                }
            }
            LinkedList<Integer> processedList = new LinkedList<>();
                
            map.entrySet().stream().forEach((entry) -> {
                processedList.addAll(entry.getValue());
            });
            colorCodeMap.put(picNo, processedList);
        }
        

        /**********************************************************************
         * readColorCodeResultFile - This method opens the color code text file
         *                           containing the color code matrix with the 
         *                           histogram bin values for each image
         * - The contents of the matrix are processed and stored in a two 
         *   dimensional array called colorCodeMatrix.
         * @return updated map
         *********************************************************************/
        private HashMap<Integer,LinkedList<Integer>> readColorCodeResultFile(){
            try {
                ObjectInputStream in = new ObjectInputStream(
                        new FileInputStream("colorCodeResult.txt"));

                return (HashMap<Integer, LinkedList<Integer>>) in.readObject();
            } catch (FileNotFoundException EE) {
                System.out.println(
                        "The file colorCodeResult.txt does not exist");
            } catch (IOException ex) {
                Logger.getLogger(CBIR.class.getName())
                        .log(Level.SEVERE, null, ex);
            } catch (ClassNotFoundException ex) {
                Logger.getLogger(CBIR.class.getName())
                        .log(Level.SEVERE, null, ex);
            }
            return (new HashMap<>());
        }
        
        
        /**********************************************************************
         * writeToColorCodeResultFile - writes updated map to file
         *********************************************************************/
        private void writeToColorCodeResultFile() {
            try {
                ObjectOutputStream out = new ObjectOutputStream(
                        new FileOutputStream("colorCodeResult.txt")); 

                out.writeObject(colorCodeMap);
            } catch (IOException ex) {
                Logger.getLogger(readImage.class.getName()).log(
                        Level.SEVERE, null, ex);
            }
        }
    }  
    
    
    
    /**************************************************************************
     * RF_Handler class - This class implements an 
     *                  ActionListener when user selects the int+CC button
     * - The image number that the user would like to find similar images for 
     *   is stored in the variable pic
     * - Selected images that user considered relevant in relevantSet
     * - The selected image's feature matrix will be normalized and compared 
     *   with all selected normalized image features
     * - The images are then arranged from most similar to the least
     *************************************************************************/
    private class RF_Handler implements ActionListener {
        private double[][] subsetNormalizedMatrix;
        private double[] weight;
        private double[] normalizedWeight;
        private double sigmaW;
        private LinkedList<Integer> newOrder;
        private double sdMin;
        
        @Override
        public void actionPerformed(ActionEvent e) {
            weight = new double[INT_CC_COLUMN_SIZE];
            normalizedWeight = new double[INT_CC_COLUMN_SIZE];
            sigmaW = 0;
            newOrder = new LinkedList<>();
            sdMin = Double.MAX_VALUE;
            Set<Integer> relevantSet = new HashSet<Integer>();
            
            
            
            if(picNo > 0) {
                // The query image should always be added
                relevantSet.add(picNo);
                // get the relevant images
                for(int image = 1; image < 101; image++ ) {
                    if(checkBox[image].isSelected()) {
                        relevantSet.add(image);
                    }
                }
                if(relevantSet.size() == 1) {
                    // if size == 1 means only query image is checked
                    relevantSet.remove(picNo);
                }
                
                
                // size = relevantSet.size + 2 for additional space for AVG/SD
                subsetNormalizedMatrix = 
                        new double[relevantSet.size() + 2][INT_CC_COLUMN_SIZE];
                int index = 0;
                for(int image : relevantSet) {
                    subsetNormalizedMatrix[index++] = normalizedMatrix[image];
                }
                
                // featureMatrixSize = length-2 to exclude AVG and SD row
                int featureMatrixSize = subsetNormalizedMatrix.length - 2;
                setAVGforSubMatrix(subsetNormalizedMatrix, featureMatrixSize);          
                setSDforSubMatrix(subsetNormalizedMatrix, featureMatrixSize);
    
                
                // sets normalized feature matrix info
                setWeight();
                setSigmaW();
                setNormalizedWeight();
                
    //          for(int i = 0; i < relevantSet.size() + 1; i++) {
    //              for(int j = 0; j < 88; j++) {
    //                  System.out.print(subsetNormalizedMatrix[i][j] + ", ");
    //              }
    //              System.out.println(subsetNormalizedMatrix[i][88]);
    //          }
                
                System.out.println("Average: ");
                for(int i = 0; i < 88; i++) {
                    System.out.print(subsetNormalizedMatrix[featureMatrixSize][i]);
                }System.out.println(subsetNormalizedMatrix[featureMatrixSize][88]);
                
                System.out.println("SD: ");
                for(int i = 0; i < 88; i++) {
                    System.out.print(subsetNormalizedMatrix[featureMatrixSize + 1][i]);
                }System.out.println(subsetNormalizedMatrix[featureMatrixSize + 1][88]);
                
                System.out.println("Weight: ");
                for(int i = 0; i < 88; i++) {
                    System.out.print(weight[i]);
                }System.out.println(weight[88]);
                
                System.out.print("Sigma weight: "); 
                System.out.println(sigmaW);
                
                System.out.print("picNo: ");
                System.out.println(picNo);
    
                System.out.print("Selected set: ");
                for(int image : relevantSet) {
                    System.out.print(image + ", ");
                }
    
                
                // if coloCodeMap doesn't have the selected image
                compareFeatures();
                
                System.out.println("newOrder size(): " + newOrder.size());
                System.out.println("newOrder: ");
                for(int i = 0; i < newOrder.size() - 1; i++) {
                    System.out.print(newOrder.get(i));
                } System.out.println(newOrder.get(newOrder.size() - 1));
                
                
                
    
                
                for(int i = 1; i < TOTAL_IMAGE; i++) {
                    buttonOrder[i] = newOrder.get(i - 1);
                }
                
                
                System.out.println("buttonOrder size(): " + buttonOrder.length);
                System.out.println("buttonOrder: ");
                for(int i = 0; i < buttonOrder.length - 1; i++) {
                    System.out.print(buttonOrder[i]);
                } System.out.println(buttonOrder[newOrder.size() - 1]);
                
                System.out.println();
                System.out.println();
                System.out.println();
                
    //            
                displayPage();
            }
        }
        
        /**********************************************************************
         * setColorCodeMap - sets the colorCode map if intensity map is empty
         *                   or doesn't have the key requested
         * - This method calculates the Manhattan Distance
         * @param i the image number
         *********************************************************************/
        private void compareFeatures() {
            Map<Double, LinkedList<Integer>> map = new TreeMap<>();
            
            double distanceKey, featureQi, featureCi; 
            for(int k = 1; k < TOTAL_IMAGE; k++) {
                distanceKey = 0;
                for(int i = 0; i < INT_CC_COLUMN_SIZE; i++) {
                    featureQi = (double)normalizedMatrix[picNo][i];
                    featureCi = (double)normalizedMatrix[k][i];
                    distanceKey += weight[i] * Math.abs(featureQi - featureCi);
                }

                if(map.keySet().contains(distanceKey)) {
                    map.get(distanceKey).add(k);
                } else {
                    LinkedList<Integer> list = new LinkedList<>();
                    list.add(k);
                    map.put(distanceKey, list);
                }
            }

            map.entrySet().stream().forEach((entry) -> {
                newOrder.addAll(entry.getValue());
            });

        }
        
        
        /**********************************************************************
         * setNormalizedWeight - sets normalized weight
         *********************************************************************/
        private void setNormalizedWeight() {
            for(int i = 0; i < INT_CC_COLUMN_SIZE; i++) {
                normalizedWeight[i] = weight[i] / sigmaW; 
                    
            }
        }
        
        
        /**********************************************************************
         * setSigmaW - sets sum of weights
         *********************************************************************/
        private void setSigmaW() {
            for(int i = 0; i < INT_CC_COLUMN_SIZE; i++) {
                sigmaW += weight[i];
            }
        }
        
        
        /**********************************************************************
         * setWeight - sets weight for each feature
         *********************************************************************/
        private void setWeight() {
            int sdrow = subsetNormalizedMatrix.length - 1;
            for(int i = 0; i < INT_CC_COLUMN_SIZE; i++) {
                double sd = subsetNormalizedMatrix[sdrow][i];
                if(sd > 0) {
                    weight[i] = 1 / sd;
                } else if (sd == 0) {
                    // sdrow - 1 is row of average
                    int avgrow = sdrow - 1;
                    double avg = subsetNormalizedMatrix[avgrow][i];
                    if(avg == 0) {
                        weight[i] = 0;
                    } else {
                        subsetNormalizedMatrix[sdrow][i] = sdMin / 2;
                        sd = subsetNormalizedMatrix[sdrow][i];
                        weight[i] = 1 / sd;
                    }
                }
            }
        }
        
        
        /**********************************************************************
         * setAVGforSubMatrix - sets average for each feature
         * - Calculates the average and save in the last row of the matrix
         * - The last two rows of the matrix are AVG row and SD row 
         * @param theMatrix to be processed
         * @param matrixSize size of feature portion 
         *********************************************************************/
        private void setAVGforSubMatrix(double[][] theMatrix, int matrixSize) {
            int average_row = matrixSize;

         // set the average row (101) for the normalized feature matrix
            for (int column = 0; column < INT_CC_COLUMN_SIZE; column++) {
                double sum = 0;
                for(int i = 0; i < matrixSize; i++) {
                    sum += theMatrix[i][column];
                }
                theMatrix[average_row][column] = sum / matrixSize; 
            }                   
        }
        
        /**********************************************************************
         * setSDforSubMatrix - sets standard deviation for each feature
         * - Calculates the standard deviation and save in the last row of the 
         *   matrix
         * - The last two rows of the matrix are AVG row and SD row 
         * @param theMatrix to be processed
         * @param matrixSize size of feature portion 
         *********************************************************************/
        private void setSDforSubMatrix(double[][] theMatrix, int matrixSize) {
            int sd_row = matrixSize + 1;
            
            // set the SD row (102) for the normalized feature matrix
            for (int column = 0; column < INT_CC_COLUMN_SIZE; column++) {
                double sum_of_square = 0;
                double avg = theMatrix[matrixSize][column];
                for(int i = 0; i < matrixSize; i++) {
//                  System.out.println(Math.pow((theMatrix[i][column] - avg), 2));
                    sum_of_square += 
                            Math.pow((theMatrix[i][column] - avg), 2);
                }
                double sd = Math.pow((sum_of_square / (matrixSize - 1)), 0.5);
                theMatrix[sd_row][column] = sd;
                if(sd > 0 && sd < sdMin) {
                    sdMin = sd;
                }
            }
        }
        

        
        
        

//        /**********************************************************************
//         * readColorCodeResultFile - This method opens the color code text file
//         *                           containing the color code matrix with the 
//         *                           histogram bin values for each image
//         * - The contents of the matrix are processed and stored in a two 
//         *   dimensional array called colorCodeMatrix.
//         * @return updated map
//         *********************************************************************/
//        private HashMap<Integer,LinkedList<Integer>> readColorCodeResultFile(){
//            try {
//                ObjectInputStream in = new ObjectInputStream(
//                        new FileInputStream("colorCodeResult.txt"));
//
//                return (HashMap<Integer, LinkedList<Integer>>) in.readObject();
//            } catch (FileNotFoundException EE) {
//                System.out.println(
//                        "The file colorCodeResult.txt does not exist");
//            } catch (IOException ex) {
//                Logger.getLogger(CBIR.class.getName())
//                        .log(Level.SEVERE, null, ex);
//            } catch (ClassNotFoundException ex) {
//                Logger.getLogger(CBIR.class.getName())
//                        .log(Level.SEVERE, null, ex);
//            }
//            return (new HashMap<>());
//        }
        
//        /**********************************************************************
//         * writeToColorCodeResultFile - writes updated map to file
//         *********************************************************************/
//        private void writeToColorCodeResultFile() {
//            try {
//                ObjectOutputStream out = new ObjectOutputStream(
//                        new FileOutputStream("colorCodeResult.txt")); 
//
//                out.writeObject(colorCodeMap);
//            } catch (IOException ex) {
//                Logger.getLogger(readImage.class.getName()).log(
//                        Level.SEVERE, null, ex);
//            }
//        }
    }
    
    /**************************************************************************
     * main - starts splash screen, executes CBIR form
     * @param args the command line arguments
     *************************************************************************/
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(CBIR.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(CBIR.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(CBIR.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(CBIR.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        CBIRSplash startup = new CBIRSplash();
        startup.setVisible(true);
        try {
            Thread.sleep(SPLASH_DURATION);
        } catch (InterruptedException e) {}
        
        /* Create and display the form */
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                CBIR app = new CBIR();
                app.setVisible(true);
            }
        });
        startup.setVisible(false);
        startup.dispose();
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutJMenuItem;
    private javax.swing.JPanel bottomRightPanel;
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JButton colorCode;
    private javax.swing.JMenuItem exitJMenuItem;
    private javax.swing.JMenu fileJMenu;
    private javax.swing.JPanel infoLable;
    private javax.swing.JButton intensity;
    private javax.swing.JLabel logoLable;
    private javax.swing.JMenuBar menuesJMenuBar;
    private javax.swing.JButton nextPage;
    private javax.swing.JLabel pageInfo;
    private javax.swing.JPanel panelLeft;
    private javax.swing.JPanel panelRight;
    private javax.swing.JLabel photographLabel;
    private javax.swing.JButton previousPage;
    private javax.swing.JMenuItem printJMenuItem;
    private javax.swing.JButton resetButton;
    private javax.swing.JMenuItem resetJMenuItem;
    private JRadioButton relevantButton;
    private JButton intCCButton;
    private JPanel rfPanel;
    private JButton selectAll;
    private JButton deselectAll;
    // End of variables declaration//GEN-END:variables
}
